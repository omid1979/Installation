Redis

ردیس یک دیتابیس key-value است و به عنوان یک in-memory cache هم استفاده میشود. ما در پروژه BTM این دیتابیس را کلاستر کردیم و در اینجا نحوه راه اندازی آن را مستند کرده ایم:

برای نصب ردیس ابتدا نیازمندی های آن را نصب میکنیم:
yum install make gcc libc6-dev tcl

 و سپس بسته موردنظر را از اینترنت میگیریم( برای این کار هم میتوان روی سرور پراکسی کرد هم بسته را جداگانه از اینترنت بگیریم و روی سرور بگذاریم)


wget http://download.redis.io/redis-stable.tar.gz
tar xvzf redis-stable.tar.gz
cd redis-stable
sudo make install

فقط در نظر بگیرید به این دلیل که ما برنامه ها را در مسیر "/opt" قرار میدهیم بهتر است بسته را در همین مسیر باز کرده و قرار دهیم.

در این نصب ما سه سرور مجازی برای هر نود ردیس در نظر گرفته ایم.بر روی هر سرور یک master و یک slave بالا می آوریم , در واقع سه نود خواهیم داشت که تشکیل کلاستر میدهند.
![920da0addeb035b033ee4901468a54e7.png](:/ad2057dc045c453b9f3202c49731c6a6)



در اصل ترتیب master و slave ها به این شکل خواهد بود:

![119a541b81c71dafde922a5f447381ca.png](:/d7d97154f5a44f32bd222579ba4d8765)

MASTER
server1:6379
SLAVE
server2:6379
SLAVE
server3:6380
MASTER
server2:6380
MASTER
server3:6381

SLAVE
server1:6381





مرحله بعد کانفیگ فایل های مربوطه است.

به یکی از سرورها ssh میکنیم و سپس به مسیر  "/opt/redis-stable/"  رفته و کانفیگ فایل های ردیس را طبق تصویر بالا انجام می دهیم.برای مثال بر روی سرور اول دو پورت ۶۳۷۹ و ۶۳۸۱ بالا می آوریم و یکی نقش master را بازی میکند که با A  مشخص شده است و دیگری یک slave میشود برای نود مستر روی سرور سوم که با C  مشخص شده است.

بنابراین برای سرور اول به این شکل عمل میکنیم:


cp redis.conf c_slave.conf
mv redis.conf a_master.conf


سپس فایل a_master.conf رو باز میکنیم و موارد زیر را در آن کانفیگ میکنیم:
#bind 127.0.0.1
protected-mode no
port 6379
daemonize yes
supervised systemd
pidfile /var/run/redis_6379.pid
logfile "/opt/log/redis_6379"
dir /opt/dumpdb
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000

سپس فایل  c_slave.conf را کانفیگ میکنیم:


#bind 127.0.0.1
protected-mode no
port 6381
daemonize yes
supervised systemd
pidfile /var/run/redis_6381.pid
logfile "/opt/log/redis_6381"
dir /opt/dumpdb
cluster-enabled yes
cluster-config-file nodes-6381.conf
cluster-node-timeout 15000


نکته: به تفاوت پورتها در کانفیگ ها دقت نمایید.مسیر دایرکتوری های لازم برای لاگ ها و فایل های دیتابیس(مقادیر متناسب با logfile و dir ) باید وجود داشته باشند.ما آنها را در مسیر /opt در نظر گرفته ایم.

همین مراحل را برای دو سرور باقیمانده با توجه به جدول زیر انجام دهید:


در سرور دوم این کارها را انجام میدهیم:
cp redis.conf a_slave.conf
mv redis.conf b_master.conf

 و در سرور سوم:
cp redis.conf b_slave.conf
mv redis.conf c_master.conf


بعد از اینکه در هر سه سرور فایل های مربوط به redis را کانفیگ کردیم , به سراغ اجرای آنها میرویم.برای اجرا و بالا آمدن سرویس در سرور اول به طریق زیر عمل میکنیم:
cd /opt/redis-stable
redis-server a_master.conf
redis-server c_slave.conf

همین کار را در دو سرور دیگر با فایل های کانفیگ مربوطه انجام میدهیم.فقط حتما از بالا آمدن پورت های موردنظر بر روی سرورها اطمینان حاصل کنید.


کار بعدی ایجاد کردن کلاسترهاست.برای انجام اینکار کافی است روی یکی از سرورها دستور زیر را اجرا کنیم:
redis-cli --cluster create 192.168.240.162:6379 192.168.240.163:6380 192.168.240.164:6381


برای چک کردن بالا آمدن سرویس ها کافی است این دستورات را بر روی سرور اجرا کنیم(برای مثال سرور اول):
redis-cli -c -h ip.of.server1 -p 6379
ip.of.server1>CLUSTER NODES


در ادامه باید نودهای slave را به نودهای master آن بشناسانیم:
redis-cli --cluster add-node 192.168.240.163:6379 192.168.240.162:6379 --cluster-slave --cluster-master-id ""
 
redis-cli --cluster add-node 192.168.240.164:6380 192.168.240.163:6380 --cluster-slave --cluster-master-id ""
 
redis-cli --cluster add-node 192.168.240.162:6381 192.168.240.164:6381 --cluster-slave --cluster-master-id ""


و باز هم برای چک کردن درستی انجام شدن این کار میتوان دستور زیر را اجرا کرد:
redis-cli -c -h ip.of.server1 -p 6379
ip.of.server1>CLUSTER INFO
 
 
or
 
 
 
 
ip.of.server1>INFO replication

به این ترتیب کلاستر ردیس ما با سه نود master و سه نود slave انجام شد.


برای تست کردن اینکه میتوان مقادیر را در دیتابیس ها وارد کرد میتوان(برای مثال) به شکل زیر عمل کرد:
ip.of.server1:6379> SET John Adams
-> Redirected to slot [6852] located at ip.of.server2:6380
OK
 
 
ip.of.server2:6380> SET James Madison
-> Redirected to slot [2237] located at ip.of.server1:6379
OK
ip.of.server1:6379> SET Andrew Jackson
-> Redirected to slot [15768] located at ip.of.server3:6381
OK
ip.of.server3:6381> GET John
-> Redirected to slot [6852] located at ip.of.server2:6380
"Adams"
ip.of.server2:6380>



مرحله بعدی درست کردن سرویس برای Redis است.برای این کار باید در هر سرور با توجه به پورتی که برای نودهای master , slave در نظر گرفته بودیم , باید یک فایل برای سرویس master و یک فایل برای سرویس slave ایجاد کنیم:
cat /etc/systemd/system/redisS.service
 
[Unit]
Description=Redis In-Memory Data Store
After=network.target
[Service]
Type=notify
ExecStart=/usr/local/bin/redis-server /opt/redis-stable/c_slave.conf
ExecStop=/usr/local/bin/redis-cli -h 127.0.0.1 -p 6381 shutdown
Restart=always
 
[Install]
WantedBy=multi-user.target
cat  /etc/systemd/system/redisM.service
 
[Unit]
Description=Redis In-Memory Data Store
After=network.target
 
[Service]
Type=notify
ExecStart=/usr/local/bin/redis-server /opt/redis-stable/a_master.conf
ExecStop=/usr/local/bin/redis-cli -h 127.0.0.1 -p 6379 shutdown
Restart=always
 
[Install]
WantedBy=multi-user.target


و سپس به این ترتیب میتوانید سرویس های ردیس را استاپ و استارت کنید:
systemctl start redisS
systemctl start redisM
systemctl status redisS
...

و برای فعال کردن سرویس ها که در زمان بوت سیستم بالا بیایند:
systemctl enable redisS
systemctl enable redisM





id: 16dd1e26147a42e48907c36b5489e296
parent_id: 9051567a85b34643b4e0252a8fdf0ac0
created_time: 2024-08-12T07:33:18.903Z
updated_time: 2024-08-12T07:34:49.163Z
is_conflict: 0
latitude: 35.68919750
longitude: 51.38897360
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2024-08-12T07:33:18.903Z
user_updated_time: 2024-08-12T07:34:49.163Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
deleted_time: 0
type_: 1